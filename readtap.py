#!/bin/python3


import os

from threading import Timer
from tapsdk import TapSDK, TapInputMode
from tapsdk.models import AirGestures
from datetime import timedelta, datetime
from asgiref.sync import async_to_sync

import asyncio
import logging
from bleak import _logger as logger


#mappings can be partially auto generated
# ex: ctrl + letter is simply
#     ctrl_tap_code + letter_tap_code
# or
#     letter_tap_code + ctrl_tap_code
#depending on which hand has the letter


# the overarching mapping can be generated by combining each left_map or right_map
# with each value in shared_map
left_map = {
    
}

right_map = {
    
}

#used for the "blank" input and any modifiers we might want accessible on either hand: eg ctrl, option, wm (cmd)
shared_map = {
    0b00000 : "blank_tap",
}

mapping = {

    0b0000000000 : "Zeros-- an invalid tap",
    0b0001001000 : "Pointers",
    0b0000110000 : "Thumbs"

}

left_tap = {"name":"left", "mac":"CE:BB:BB:2E:60:99"}
right_tap = {"name":"right", "mac":"F3:64:D7:5D:8D:D1"}

taps_by_mac = {left_tap["mac"]:left_tap["name"], right_tap["mac"]:right_tap["name"]}


def reverseBits(tapcode):
    return int('{:05b}'.format(tapcode)[::-1], 2)

#tap decoding:
# - hand comes in
# - if other hand has come in, and was recent (< 5ms?)
# -     then is a two hand combo
# - else is a one hand combo

other_hand = None
other_hand_code = None
other_hand_time = None

other_hand_timer = None

def WaitTap(hand, command):
    print("("+hand+") recognized=" + str(command))

#since the bleak lib insists on using synchronous callbacks instead of async promises, etc we have to get a little stupid and use threading.
# threading, callbacks, and asyncio all in one. how fun
# if its stupid, but works, it is still stupid

def DecodeTap(loop, hand, tapcode):
    print("in DecodeTap")
    global other_hand
    global other_hand_code
    global other_hand_time
    global other_hand_timer

    now = datetime.now()
    if (hand == "left"):
        tapcode = tapcode<<5
    if (other_hand != None) and ((now - other_hand_time) < timedelta(milliseconds=50)):
        other_hand_timer.cancel()
        command = other_hand_code | tapcode
        print("(dual) recognized=" + str(command))
        other_hand = None
        return

    other_hand = hand
    other_hand_code = tapcode
    other_hand_time = datetime.now()
    other_hand_timer = Timer(0.07, WaitTap, args = [hand, tapcode])
    other_hand_timer.start()

def notification_handler(sender, data):
    """Simple notification handler which prints the data received."""
    print("{0}: {1}".format(sender, data))


def OnMouseModeChange(address, identifier, mouse_mode):
    print(identifier + " changed to mode " + str(mouse_mode))

def OnTapped(loop, address, identifier, tapcode):
    if (taps_by_mac[address] == "right"):
        tapcode = reverseBits(tapcode)
    print(taps_by_mac[address] + " (" + address + ") tapped " + str(tapcode))
    DecodeTap(loop, taps_by_mac[address], tapcode)

def OnTapConnected(self, identifier, name, fw):
    print(identifier + " Tap: " + str(name), " FW Version: ", fw)


def OnTapDisconnected(self, identifier):
    print(identifier + " Tap: " + identifier + " disconnected")


def OnMoused(address, identifier, vx, vy, isMouse):
    print(identifier + " mouse movement: %d, %d, %d" % (vx, vy, isMouse))



async def run(loop=None, debug=True):
    # if debug:
    #     import sys

    #     loop.set_debug(True)
    #     h = logging.StreamHandler(sys.stdout)
    #     h.setLevel(logging.WARNING)
    #     logger.addHandler(h)
    left = TapSDK(left_tap["mac"], loop)
    right = TapSDK(right_tap["mac"], loop)



    if not await left.client.connect_retrieved():
        print("Error connecting to {}".format(left_tap["mac"]))
        return None

    print("Connected to {}".format(left.client.address))

    await left.set_input_mode(TapInputMode("controller"))
    await left.register_tap_events(OnTapped)
    await left.register_mouse_events(OnMoused)

    if not await right.client.connect_retrieved():
        print("Error connecting to {}".format(right_tap["mac"]))
        return None

    print("Connected to {}".format(right.client.address))

    await right.set_input_mode(TapInputMode("controller"))
    await right.register_tap_events(OnTapped)
    await right.register_mouse_events(OnMoused)


    #TODO: could use tap.client.list_connected_taps to detect disconnects?
    while (True):
        await asyncio.sleep(100.0)

        # print("Connected to {}".format(client.client.address))
        # await client.register_raw_data_events(OnRawData)
        # await client.register_mouse_events(OnMoused)

        # logger.info("Changing to text mode")
        #await client.set_input_mode(TapInputMode("text"))
        # await asyncio.sleep(30))
        #logger.info("Changing to raw mode")
        #await client.set_input_mode(TapInputMode("raw"))

        # await client.send_vibration_sequence([100, 200, 300, 400, 500])


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(run(loop, True))
